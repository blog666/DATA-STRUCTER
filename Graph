/***最小生成树***/

/**普里姆算法**prim*/

/**普里姆算法的核心思想与adjkstra算法无大的区别

主要是无路径这一说法**/

void prim(Mgraph G,int v0,int &sum)//sum 用来更新生成树的权值
{
  int i,j,v,u,min,set[Maxsize],int dist[Maxsize];
  for(i=0;i<G->vn;++i)
  {
  set[i]=0;
  dist[i]=G->edges[v0][i];
  }
  set[v0]=1;
  for(i=0;i<G->vn-1;++i)
  {
    min=INF;
    for(j=0;j<G->vn;++j)
    {
      if(set[j]==0&&dist[j]<min)
      {
       min=dist[j]];
       u=j;
      }
    }
    set[u]=1;
    v=j;
    sum+=min;
    for(j=0;j<G->vn;++j)
    {
       if(set[j]==0&&dist[j]>G->edges[v][j])
       {
         dist[j]=G->edges[v][j];
       }
    }
}


/***prim算法时间复杂度为O（n的平方），适用于稠密图***/


/***克鲁斯卡尔算法***kruskal***/

/**kruskal算法的思想为：每次从图中选择最小边并入生成树中，
但也注意不能构成回路，因此用到并查集的算法**/

typedef struct {
int a,b;//一条边的两个顶点
int weight;
}Road;

Road road[Maxsize];//边的集合
int v[Maxsize];//并查集数组

int GETROOT(int a)
{
   while(V[a]!=a)a=V[a];
  return a;
}

void Kruskal(Mgraph G,Road road[])
{
   int i;
   int N,e,a,b;
   N=G->vn;
   E=G->en;
   for(i=0;i<G->N;++i)v[i]=i;
   sort(Road,E);//对Road 数组中的边按权值从小到大排序
   for(i=0;i<E;++i)
   {
      a=GETROOT(road[i].a);
      b=GETROOT(road[i].b);
      if(a!=b)
      {
         v[a]=b;
      }
   }
}
